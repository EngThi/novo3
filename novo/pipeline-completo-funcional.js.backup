require('dotenv').config({ path: require('path').join(__dirname, '.env') });

const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

class PipelineCompletoFuncional {
    constructor() {
        // CHAVES REAIS DO .ENV
        this.geminiKeys = [
            process.env.GEMINI_API_KEY,
            process.env.GEMINI_API_KEY_2,
            process.env.GEMINI_API_KEY_3
        ].filter(key => key && key.length > 20);
        
        this.outputDir = '/home/user/main/novo3/novo/outputs';
        this.imageDir = path.join(this.outputDir, 'images');
        this.audioDir = path.join(this.outputDir, 'audio');
        this.videoDir = path.join(this.outputDir, 'videos');
        
        this.ensureDirectories();
        
        console.log('üöÄ Pipeline Completo Funcional V6.0');
        console.log(`   üîë Chaves Gemini: ${this.geminiKeys.length}`);
        console.log(`   üìÅ Outputs: ${this.outputDir}`);
    }
    
    ensureDirectories() {
        [this.outputDir, this.imageDir, this.audioDir, this.videoDir].forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
            }
        });
    }
    
    async gerarVideoCompleto(topic) {
        const jobId = `complete-${Date.now()}`;
        
        try {
            console.log(`\nüöÄ PIPELINE COMPLETO: ${topic}`);
            console.log('=====================================');
            
            // PASSO 1: Gerar Script
            console.log('üß† 1/5 - Gerando script com Gemini 2.5 Flash...');
            const script = await this.gerarScript(topic);
            console.log(`‚úÖ Script gerado! T√≠tulo: ${script.title}`);
            
            // PASSO 2: Gerar Prompts Visuais
            console.log('ÔøΩÔøΩ 2/5 - Gerando prompts visuais...');
            const prompts = await this.gerarPromptsVisuais(script);
            console.log(`‚úÖ ${prompts.length} prompts visuais gerados`);
            
            // PASSO 3: Gerar Imagens
            console.log('üñºÔ∏è 3/5 - Gerando imagens...');
            const imagens = await this.gerarImagens(prompts, jobId);
            console.log(`‚úÖ ${imagens.length} imagens geradas`);
            
            // PASSO 4: Gerar Narra√ß√£o
            console.log('üéôÔ∏è 4/5 - Gerando narra√ß√£o...');
            const audioPath = await this.gerarNarracao(script.content, jobId);
            console.log(`‚úÖ Narra√ß√£o gerada: ${path.basename(audioPath)}`);
            
            // PASSO 5: Montar V√≠deo Final
            console.log('üé¨ 5/5 - Montando v√≠deo final...');
            const videoPath = await this.montarVideoFinal(script, imagens, audioPath, jobId);
            console.log(`‚úÖ V√≠deo completo: ${path.basename(videoPath)}`);
            
            return {
                success: true,
                jobId,
                script,
                imagens: imagens.length,
                videoPath,
                videoUrl: `/videos/${path.basename(videoPath)}`,
                duration: '180s',
                quality: 'HD 1280x720'
            };
            
        } catch (error) {
            console.log(`‚ùå Pipeline falhou: ${error.message}`);
            throw error;
        }
    }
    
    async gerarScript(topic) {
        const currentDate = new Date().toLocaleDateString('pt-BR');
        
        const prompt = `üöÄ PIPELINE COMPLETO V6.0 - GEMINI 2.5 FLASH

T√ìPICO: "${topic}"
DATA: ${currentDate}

IMPORTANTE: Mencione a data no in√≠cio do roteiro.

Crie roteiro completo para v√≠deo de 3 minutos:

ESTRUTURA:
1. ABERTURA (0-20s): Gancho + data
2. DESENVOLVIMENTO (20s-2min20s): 4-5 pontos principais
3. CONCLUS√ÉO (2min20s-3min): Resumo + CTA

Responda APENAS JSON v√°lido:
{
  "title": "T√≠tulo otimizado para YouTube",
  "content": "Roteiro narrado completo (texto falado)",
  "hook": "Frase de abertura impactante",
  "keyPoints": ["ponto1", "ponto2", "ponto3", "ponto4"],
  "duration": "180",
  "seoKeywords": ["palavra1", "palavra2", "atual"],
  "callToAction": "CTA espec√≠fico"
}`;

        for (let i = 0; i < this.geminiKeys.length; i++) {
            try {
                const response = await axios.post(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${this.geminiKeys[i]}`,
                    {
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.8,
                            maxOutputTokens: 3000
                        }
                    },
                    { timeout: 30000 }
                );
                
                const text = response.data.candidates[0].content.parts[0].text;
                return this.parseJSON(text);
                
            } catch (error) {
                console.log(`‚ùå Chave ${i + 1}: ${error.response?.data?.error?.message || error.message}`);
                continue;
            }
        }
        
        throw new Error('Todas as chaves Gemini falharam para script');
    }
    
    async gerarPromptsVisuais(script) {
        const prompts = [
            `Professional tech news studio background, modern design, blue lighting, 16:9 aspect ratio`,
            `Abstract technology illustration, AI neural networks, futuristic design, blue and purple colors`,
            `Modern data visualization, charts and graphs, professional business style`,
            `Futuristic technology concept, digital transformation, modern aesthetic`,
            `Professional business meeting, modern office, technology discussion`,
            `Global technology trends, world map with connections, modern design`
        ];
        
        return prompts.map((prompt, index) => ({
            scene: index + 1,
            description: `Cena ${index + 1}`,
            prompt: prompt
        }));
    }
    
    async gerarImagens(prompts, jobId) {
        const imagens = [];
        
        for (let i = 0; i < Math.min(prompts.length, 6); i++) {
            try {
                console.log(`üé® Gerando imagem ${i + 1}/${prompts.length}...`);
                
                // Tentar Nano Banana primeiro
                const imagem = await this.gerarImagemNanoBanana(prompts[i].prompt, jobId, i + 1);
                if (imagem) {
                    imagens.push(imagem);
                    continue;
                }
                
                // Fallback para Pollinations
                const imagemPoll = await this.gerarImagemPollinations(prompts[i].prompt, jobId, i + 1);
                if (imagemPoll) {
                    imagens.push(imagemPoll);
                }
                
            } catch (error) {
                console.log(`‚ùå Erro imagem ${i + 1}: ${error.message}`);
                
                // Criar placeholder se falhar
                const placeholderPath = await this.criarPlaceholder(jobId, i + 1);
                imagens.push({
                    filename: path.basename(placeholderPath),
                    imagePath: placeholderPath,
                    imageUrl: `/images/${path.basename(placeholderPath)}`,
                    provider: 'placeholder'
                });
            }
        }
        
        return imagens;
    }
    
    async gerarImagemNanoBanana(prompt, jobId, sceneIndex) {
        const imagePrompt = `Generate high-quality professional image: ${prompt}. Resolution: 1280x720, 16:9 aspect ratio, photorealistic, detailed`;
        
        for (const apiKey of this.geminiKeys) {
            try {
                const response = await axios.post(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,
                    {
                        contents: [{ parts: [{ text: imagePrompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 1000,
                            responseModalities: ['Image']
                        }
                    },
                    { timeout: 45000 }
                );
                
                const parts = response.data.candidates[0].content.parts;
                const imagePart = parts.find(part => part.inlineData);
                
                if (imagePart) {
                    const filename = `${jobId}_scene${sceneIndex.toString().padStart(2, '0')}_nano.png`;
                    const imagePath = path.join(this.imageDir, filename);
                    
                    const buffer = Buffer.from(imagePart.inlineData.data, 'base64');
                    fs.writeFileSync(imagePath, buffer);
                    
                    console.log(`‚úÖ Nano Banana: ${filename}`);
                    
                    return {
                        filename,
                        imagePath,
                        imageUrl: `/images/${filename}`,
                        provider: 'nano-banana'
                    };
                }
                
            } catch (error) {
                if (error.response?.data?.error?.message?.includes('quota')) {
                    console.log(`üîÑ Nano Banana quota excedida, tentando Pollinations...`);
                    return null; // Usar fallback
                }
                continue;
            }
        }
        
        return null;
    }
    
    async gerarImagemPollinations(prompt, jobId, sceneIndex) {
        const enhancedPrompt = `Professional high quality image: ${prompt}. 16:9 aspect ratio, detailed photography, 8k resolution`;
        const encodedPrompt = encodeURIComponent(enhancedPrompt);
        const seed = Date.now() + sceneIndex;
        
        const imageUrl = `https://pollinations.ai/p/${encodedPrompt}?width=1280&height=720&seed=${seed}&model=flux`;
        
        try {
            const response = await axios.get(imageUrl, {
                responseType: 'arraybuffer',
                timeout: 20000
            });
            
            if (response.data && response.data.byteLength > 5000) {
                const filename = `${jobId}_scene${sceneIndex.toString().padStart(2, '0')}_poll.png`;
                const imagePath = path.join(this.imageDir, filename);
                
                fs.writeFileSync(imagePath, Buffer.from(response.data));
                
                console.log(`‚úÖ Pollinations: ${filename}`);
                
                return {
                    filename,
                    imagePath,
                    imageUrl: `/images/${filename}`,
                    provider: 'pollinations'
                };
            }
            
        } catch (error) {
            console.log(`‚ùå Pollinations erro: ${error.message}`);
        }
        
        return null;
    }
    
    async criarPlaceholder(jobId, sceneIndex) {
        const filename = `${jobId}_scene${sceneIndex.toString().padStart(2, '0')}_placeholder.png`;
        const imagePath = path.join(this.imageDir, filename);
        
        // Criar imagem placeholder com FFmpeg
        await new Promise((resolve, reject) => {
            const ffmpeg = spawn('ffmpeg', [
                '-f', 'lavfi',
                '-i', `color=c=blue:size=1280x720:duration=1`,
                '-vf', `drawtext=text='Cena ${sceneIndex}':fontcolor=white:fontsize=60:x=(w-text_w)/2:y=(h-text_h)/2`,
                '-frames:v', '1',
                '-y',
                imagePath
            ]);
            
            ffmpeg.on('close', (code) => {
                if (code === 0) {
                    console.log(`‚úÖ Placeholder: ${filename}`);
                    resolve();
                } else {
                    reject(new Error(`FFmpeg placeholder falhou: ${code}`));
                }
            });
        });
        
        return imagePath;
    }
    
    async gerarNarracao(content, jobId) {
        const audioFilename = `${jobId}_narration.wav`;
        const audioPath = path.join(this.audioDir, audioFilename);
        
        // Limpar texto para TTS
        const textoLimpo = content
            .replace(/[{}[\]]/g, '')
            .replace(/"/g, '')
            .replace(/\n/g, ' ')
            .replace(/\s+/g, ' ')
            .substring(0, 3000); // Limitar tamanho
        
        try {
            // Usar Google TTS via gTTS (Python)
            await new Promise((resolve, reject) => {
                const gtts = spawn('python3', ['-c', `
import sys
from gtts import gTTS
import io

text = """${textoLimpo}"""
tts = gTTS(text=text, lang='pt', slow=False)
tts.save("${audioPath}")
print("‚úÖ Narra√ß√£o gTTS gerada")
                `]);
                
                gtts.on('close', (code) => {
                    if (code === 0) {
                        console.log(`‚úÖ gTTS: ${audioFilename}`);
                        resolve();
                    } else {
                        reject(new Error(`gTTS falhou: ${code}`));
                    }
                });
                
                gtts.on('error', reject);
            });
            
        } catch (error) {
            console.log(`‚ö†Ô∏è gTTS falhou, usando espeak: ${error.message}`);
            
            // Fallback para espeak
            await new Promise((resolve, reject) => {
                const espeak = spawn('espeak', [
                    '-v', 'pt',
                    '-s', '150',
                    '-w', audioPath,
                    textoLimpo
                ]);
                
                espeak.on('close', (code) => {
                    if (code === 0) {
                        console.log(`‚úÖ espeak: ${audioFilename}`);
                        resolve();
                    } else {
                        reject(new Error(`espeak falhou: ${code}`));
                    }
                });
            });
        }
        
        return audioPath;
    }
    
    async montarVideoFinal(script, imagens, audioPath, jobId) {
        const videoFilename = `${jobId}_final.mp4`;
        const videoPath = path.join(this.videoDir, videoFilename);
        
        // Criar lista de imagens para FFmpeg
        const imageListPath = path.join(this.outputDir, `${jobId}_images.txt`);
        const imageList = imagens.map(img => `file '${img.imagePath}'`).join('\n');
        fs.writeFileSync(imageListPath, imageList);
        
        console.log(`üé¨ Montando v√≠deo com ${imagens.length} imagens...`);
        
        await new Promise((resolve, reject) => {
            const ffmpegArgs = [
                // Input de imagens
                '-f', 'concat',
                '-safe', '0',
                '-i', imageListPath,
                
                // Input de √°udio
                '-i', audioPath,
                
                // Configura√ß√µes de v√≠deo
                '-c:v', 'libx264',
                '-r', '25',
                '-pix_fmt', 'yuv420p',
                
                // Configura√ß√µes de √°udio
                '-c:a', 'aac',
                '-b:a', '128k',
                
                // Filtros
                '-vf', `scale=1280:720:force_original_aspect_ratio=decrease,pad=1280:720:(ow-iw)/2:(oh-ih)/2,fps=25`,
                
                // Dura√ß√£o baseada no √°udio
                '-shortest',
                
                '-y',
                videoPath
            ];
            
            const ffmpeg = spawn('ffmpeg', ffmpegArgs);
            
            ffmpeg.stderr.on('data', (data) => {
                const output = data.toString();
                if (output.includes('time=')) {
                    const timeMatch = output.match(/time=(\d{2}:\d{2}:\d{2})/);
                    if (timeMatch) {
                        process.stdout.write(`\rüé¨ Processando: ${timeMatch[1]}`);
                    }
                }
            });
            
            ffmpeg.on('close', (code) => {
                console.log(`\n`);
                if (code === 0) {
                    console.log(`‚úÖ V√≠deo final: ${videoFilename}`);
                    
                    // Limpar arquivo tempor√°rio
                    fs.unlinkSync(imageListPath);
                    
                    resolve();
                } else {
                    reject(new Error(`FFmpeg falhou: ${code}`));
                }
            });
            
            ffmpeg.on('error', reject);
        });
        
        return videoPath;
    }
    
    parseJSON(content) {
        try {
            return JSON.parse(content);
        } catch (e) {
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                try {
                    return JSON.parse(jsonMatch[0]);
                } catch (e2) {
                    return this.createFallback();
                }
            }
            return this.createFallback();
        }
    }
    
    createFallback() {
        const currentDate = new Date().toLocaleDateString('pt-BR');
        
        return {
            title: `An√°lise Completa - ${currentDate}`,
            content: `Bem-vindos ao nosso canal! Hoje, ${currentDate}, vamos analisar os temas mais importantes. Este √© um roteiro completo com an√°lise detalhada dos principais pontos. Fiquem conosco at√© o final para descobrir insights exclusivos. N√£o se esque√ßam de curtir o v√≠deo e se inscrever no canal!`,
            hook: `Descubra os temas mais importantes de hoje, ${currentDate}`,
            keyPoints: ["An√°lise principal", "Pontos importantes", "Conclus√µes", "Pr√≥ximos passos"],
            duration: "180",
            seoKeywords: ["analise", currentDate.replace(/\//g, ''), "completa"],
            callToAction: "Curta, se inscreva e ative as notifica√ß√µes!"
        };
    }
}

// EXECUTAR PIPELINE COMPLETO
async function main() {
    if (process.argv.length < 3) {
        console.log('üìã Uso: node pipeline-completo-funcional.js "seu t√≥pico aqui"');
        process.exit(1);
    }
    
    const topic = process.argv.slice(2).join(' ');
    const pipeline = new PipelineCompletoFuncional();
    
    try {
        const resultado = await pipeline.gerarVideoCompleto(topic);
        
        console.log('\nüéä PIPELINE COMPLETO FINALIZADO!');
        console.log('=====================================');
        console.log(`üìπ V√≠deo: ${resultado.videoPath}`);
        console.log(`üåê URL: ${resultado.videoUrl}`);
        console.log(`üé® Imagens: ${resultado.imagens}`);
        console.log(`‚è±Ô∏è Dura√ß√£o: ${resultado.duration}`);
        console.log(`üìä Qualidade: ${resultado.quality}`);
        
    } catch (error) {
        console.log(`\nüí• ERRO: ${error.message}`);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}

module.exports = PipelineCompletoFuncional;
