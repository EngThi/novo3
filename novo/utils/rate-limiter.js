const EventEmitter = require('events');

/**
 * Sistema Inteligente de Rate Limiting com Pool de API Keys
 * Elimina timeouts do Gemini TTS atrav√©s de rota√ß√£o de keys e throttling
 */
class RateLimiter extends EventEmitter {
    constructor(options = {}) {
        super();
        
        this.requestsPerMinute = options.requestsPerMinute || 15; // Conservative limit
        this.burstLimit = options.burstLimit || 3; // Burst requests allowed
        this.timeWindow = 60000; // 1 minute
        this.requestQueue = [];
        this.apiKeyPool = [];
        this.currentKeyIndex = 0;
        this.isProcessing = false;
        
        // Tracking por API key
        this.keyStats = new Map();
        
        // Configura√ß√µes avan√ßadas
        this.config = {
            baseDelay: 4000,      // 4s between requests
            burstDelay: 1000,     // 1s for burst requests
            timeoutDelay: 45000,  // 45s timeout (vs 60s default)
            maxRetries: 3,
            backoffMultiplier: 1.5
        };
        
        this.initializeApiPool();
        this.startProcessing();
        
        console.log('üö¶ Rate Limiter inicializado com pool inteligente');
    }
    
    // === INICIALIZA√á√ÉO DO POOL ===
    initializeApiPool() {
        // Carregar m√∫ltiplas API keys
        const keys = [];
        
        // Primary key
        if (process.env.GEMINI_API_KEY) {
            keys.push(process.env.GEMINI_API_KEY);
        }
        
        // Secondary keys (para evitar rate limits)
        for (let i = 2; i <= 10; i++) {
            const key = process.env[`GEMINI_API_KEY_${i}`];
            if (key) keys.push(key);
        }
        
        this.apiKeyPool = keys.map((key, index) => ({
            id: index + 1,
            key: key.trim(),
            available: true,
            lastUsed: 0,
            requestCount: 0,
            errorCount: 0,
            avgResponseTime: 0,
            status: 'ready'
        }));
        
        // Inicializar stats
        this.apiKeyPool.forEach(apiKey => {
            this.keyStats.set(apiKey.id, {\n                requests: [],\n                errors: 0,\n                totalTime: 0,\n                blocked: false,\n                blockedUntil: 0\n            });\n        });\n        \n        console.log(`üîë API Pool inicializado: ${this.apiKeyPool.length} keys dispon√≠veis`);\n        \n        if (this.apiKeyPool.length === 0) {\n            throw new Error('Nenhuma API key encontrada. Configure GEMINI_API_KEY no .env');\n        }\n    }\n    \n    // === SELE√á√ÉO INTELIGENTE DE API KEY ===\n    selectBestApiKey() {\n        // Filtrar keys dispon√≠veis\n        const availableKeys = this.apiKeyPool.filter(key => {\n            const stats = this.keyStats.get(key.id);\n            return key.available && \n                   !stats.blocked && \n                   Date.now() > stats.blockedUntil;\n        });\n        \n        if (availableKeys.length === 0) {\n            // Todas as keys est√£o bloqueadas, usar a menos bloqueada\n            const leastBlockedKey = this.apiKeyPool.reduce((best, current) => {\n                const currentStats = this.keyStats.get(current.id);\n                const bestStats = this.keyStats.get(best.id);\n                return currentStats.blockedUntil < bestStats.blockedUntil ? current : best;\n            });\n            \n            console.log(`‚ö†Ô∏è Todas as keys bloqueadas, usando menos bloqueada: ${leastBlockedKey.id}`);\n            return leastBlockedKey;\n        }\n        \n        // Selecionar key com melhor performance\n        const bestKey = availableKeys.reduce((best, current) => {\n            const currentStats = this.keyStats.get(current.id);\n            const bestStats = this.keyStats.get(best.id);\n            \n            // Priorizar por menor taxa de erro e menor tempo de resposta\n            const currentScore = (currentStats.errors / Math.max(1, current.requestCount)) + \n                               (current.avgResponseTime / 10000);\n            const bestScore = (bestStats.errors / Math.max(1, best.requestCount)) + \n                            (best.avgResponseTime / 10000);\n            \n            return currentScore < bestScore ? current : best;\n        });\n        \n        return bestKey;\n    }\n    \n    // === PROCESSAMENTO DE FILA ===\n    startProcessing() {\n        setInterval(() => {\n            if (!this.isProcessing && this.requestQueue.length > 0) {\n                this.processNextRequest();\n            }\n        }, 100); // Check every 100ms\n    }\n    \n    async processNextRequest() {\n        if (this.requestQueue.length === 0) return;\n        \n        this.isProcessing = true;\n        const request = this.requestQueue.shift();\n        \n        try {\n            const apiKey = this.selectBestApiKey();\n            const stats = this.keyStats.get(apiKey.id);\n            \n            // Verificar se precisa aguardar\n            const timeSinceLastRequest = Date.now() - apiKey.lastUsed;\n            const requiredDelay = this.calculateDelay(apiKey, stats);\n            \n            if (timeSinceLastRequest < requiredDelay) {\n                const waitTime = requiredDelay - timeSinceLastRequest;\n                console.log(`‚è≥ Aguardando ${waitTime}ms para API key ${apiKey.id}`);\n                await this.sleep(waitTime);\n            }\n            \n            // Executar request\n            const startTime = Date.now();\n            apiKey.status = 'processing';\n            \n            try {\n                const result = await request.execute(apiKey.key);\n                \n                // Success - atualizar stats\n                const responseTime = Date.now() - startTime;\n                this.recordSuccess(apiKey, responseTime);\n                \n                request.resolve(result);\n                \n            } catch (error) {\n                // Error - handle intelligently\n                await this.handleRequestError(apiKey, error, request);\n            }\n            \n        } catch (error) {\n            console.error('üö® Erro cr√≠tico no rate limiter:', error.message);\n            request.reject(error);\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n    \n    // === TRATAMENTO DE ERROS ===\n    async handleRequestError(apiKey, error, request) {\n        const stats = this.keyStats.get(apiKey.id);\n        stats.errors++;\n        apiKey.errorCount++;\n        \n        console.log(`‚ùå Erro na API key ${apiKey.id}: ${error.message}`);\n        \n        // Classificar erro\n        if (error.response?.status === 429 || error.message.includes('rate limit')) {\n            // Rate limit - bloquear key temporariamente\n            stats.blocked = true;\n            stats.blockedUntil = Date.now() + (30 * 60 * 1000); // 30 minutos\n            apiKey.status = 'rate_limited';\n            console.log(`üö´ API key ${apiKey.id} bloqueada por rate limit at√© ${new Date(stats.blockedUntil).toLocaleTimeString()}`);\n            \n        } else if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {\n            // Timeout - aumentar delay para pr√≥ximas requests\n            stats.blockedUntil = Date.now() + (5 * 60 * 1000); // 5 minutos\n            apiKey.status = 'timeout';\n            console.log(`‚è∞ API key ${apiKey.id} em cooldown por timeout`);\n            \n        } else if (error.response?.status === 401 || error.response?.status === 403) {\n            // Auth error - marcar key como inv√°lida\n            apiKey.available = false;\n            apiKey.status = 'invalid';\n            console.log(`üîí API key ${apiKey.id} marcada como inv√°lida`);\n            \n        } else {\n            // Erro gen√©rico - cooldown curto\n            stats.blockedUntil = Date.now() + (2 * 60 * 1000); // 2 minutos\n            apiKey.status = 'error';\n        }\n        \n        // Tentar retry com outra key se dispon√≠vel\n        const availableKeys = this.apiKeyPool.filter(k => \n            k.available && k.id !== apiKey.id && !this.keyStats.get(k.id).blocked\n        );\n        \n        if (availableKeys.length > 0 && request.retries < this.config.maxRetries) {\n            request.retries++;\n            console.log(`üîÑ Retry ${request.retries}/${this.config.maxRetries} com outra API key`);\n            \n            // Re-queue with exponential backoff\n            const delay = this.config.baseDelay * Math.pow(this.config.backoffMultiplier, request.retries - 1);\n            setTimeout(() => {\n                this.requestQueue.unshift(request); // Priority retry\n            }, delay);\n            \n        } else {\n            // Sem keys dispon√≠veis ou max retries\n            console.log(`üíÄ Request falhou definitivamente ap√≥s ${request.retries} tentativas`);\n            request.reject(error);\n        }\n    }\n    \n    // === C√ÅLCULO DE DELAY INTELIGENTE ===\n    calculateDelay(apiKey, stats) {\n        let delay = this.config.baseDelay;\n        \n        // Aumentar delay baseado em erros recentes\n        const recentErrors = stats.errors;\n        if (recentErrors > 2) {\n            delay *= Math.pow(1.5, Math.min(recentErrors - 2, 5));\n        }\n        \n        // Reduzir delay para keys com boa performance\n        if (apiKey.errorCount === 0 && apiKey.requestCount > 5) {\n            delay *= 0.7; // 30% faster for good keys\n        }\n        \n        // Burst handling\n        const recentRequests = stats.requests.filter(\n            r => Date.now() - r.timestamp < this.timeWindow\n        ).length;\n        \n        if (recentRequests >= this.burstLimit) {\n            delay = Math.max(delay, (60000 / this.requestsPerMinute)); // Enforce rate limit\n        } else if (recentRequests < this.burstLimit) {\n            delay = Math.min(delay, this.config.burstDelay); // Allow burst\n        }\n        \n        return Math.min(delay, 60000); // Max 1 minute delay\n    }\n    \n    // === INTERFACE P√öBLICA ===\n    async execute(requestFunction, options = {}) {\n        return new Promise((resolve, reject) => {\n            const request = {\n                execute: requestFunction,\n                resolve,\n                reject,\n                retries: 0,\n                priority: options.priority || 0,\n                timestamp: Date.now()\n            };\n            \n            // Insert based on priority\n            const insertIndex = this.requestQueue.findIndex(r => r.priority < request.priority);\n            if (insertIndex === -1) {\n                this.requestQueue.push(request);\n            } else {\n                this.requestQueue.splice(insertIndex, 0, request);\n            }\n            \n            console.log(`üìù Request enfileirado (${this.requestQueue.length} na fila, prioridade: ${request.priority})`);\n        });\n    }\n    \n    // === UTILS ===\n    recordSuccess(apiKey, responseTime) {\n        apiKey.lastUsed = Date.now();\n        apiKey.requestCount++;\n        apiKey.avgResponseTime = (apiKey.avgResponseTime * (apiKey.requestCount - 1) + responseTime) / apiKey.requestCount;\n        apiKey.status = 'success';\n        \n        const stats = this.keyStats.get(apiKey.id);\n        stats.requests.push({\n            timestamp: Date.now(),\n            responseTime,\n            success: true\n        });\n        \n        // Limpar requests antigas\n        stats.requests = stats.requests.filter(\n            r => Date.now() - r.timestamp < this.timeWindow\n        );\n        \n        console.log(`‚úÖ Request sucesso com API key ${apiKey.id} (${responseTime}ms)`);\n    }\n    \n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    // === ESTAT√çSTICAS ===\n    getPoolStats() {\n        const stats = {\n            total_keys: this.apiKeyPool.length,\n            available_keys: this.apiKeyPool.filter(k => k.available).length,\n            queue_size: this.requestQueue.length,\n            keys_detail: []\n        };\n        \n        this.apiKeyPool.forEach(key => {\n            const keyStats = this.keyStats.get(key.id);\n            stats.keys_detail.push({\n                id: key.id,\n                status: key.status,\n                available: key.available,\n                requests: key.requestCount,\n                errors: key.errorCount,\n                avg_time: `${key.avgResponseTime.toFixed(0)}ms`,\n                blocked_until: keyStats.blocked ? new Date(keyStats.blockedUntil).toLocaleTimeString() : 'N/A'\n            });\n        });\n        \n        return stats;\n    }\n    \n    printStats() {\n        const stats = this.getPoolStats();\n        \n        console.log('\\nüö¶ RATE LIMITER STATS');\n        console.log('=====================');\n        console.log(`üìä Pool: ${stats.available_keys}/${stats.total_keys} keys dispon√≠veis`);\n        console.log(`üìù Fila: ${stats.queue_size} requests aguardando`);\n        console.log('\\nüîë Detalhes das Keys:');\n        \n        stats.keys_detail.forEach(key => {\n            const statusIcon = {\n                'ready': 'üü¢',\n                'processing': 'üü°', \n                'success': '‚úÖ',\n                'rate_limited': 'üö´',\n                'timeout': '‚è∞',\n                'error': '‚ùå',\n                'invalid': 'üîí'\n            }[key.status] || '‚ùì';\n            \n            console.log(`   ${statusIcon} Key ${key.id}: ${key.requests} req, ${key.errors} err, ${key.avg_time}`);\n            if (key.blocked_until !== 'N/A') {\n                console.log(`     üö´ Bloqueada at√©: ${key.blocked_until}`);\n            }\n        });\n        \n        console.log('=====================\\n');\n    }\n    \n    // === CONFIGURA√á√ÉO DIN√ÇMICA ===\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        console.log('‚öôÔ∏è Rate limiter config atualizada:', newConfig);\n    }\n    \n    // === HEALTH CHECK ===\n    async healthCheck() {\n        const availableKeys = this.apiKeyPool.filter(k => k.available).length;\n        const queueSize = this.requestQueue.length;\n        \n        const health = {\n            status: 'healthy',\n            available_keys: availableKeys,\n            queue_size: queueSize,\n            issues: []\n        };\n        \n        if (availableKeys === 0) {\n            health.status = 'critical';\n            health.issues.push('Nenhuma API key dispon√≠vel');\n        } else if (availableKeys === 1) {\n            health.status = 'warning';\n            health.issues.push('Apenas 1 API key dispon√≠vel (riscos de rate limit)');\n        }\n        \n        if (queueSize > 10) {\n            health.status = health.status === 'healthy' ? 'warning' : 'critical';\n            health.issues.push(`Fila muito cheia: ${queueSize} requests`);\n        }\n        \n        return health;\n    }\n    \n    // === WRAPPER PARA GEMINI TTS ===\n    async executeGeminiTTS(text, voice, options = {}) {\n        return this.execute(async (apiKey) => {\n            const axios = require('axios');\n            \n            const payload = {\n                contents: [{ parts: [{ text: text }] }],\n                generationConfig: {\n                    responseModalities: [\"AUDIO\"],\n                    speechConfig: {\n                        voiceConfig: {\n                            prebuiltVoiceConfig: { voiceName: voice }\n                        }\n                    }\n                },\n                model: \"gemini-2.5-flash-preview-tts\"\n            };\n            \n            const response = await axios.post(\n                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`,\n                payload,\n                {\n                    headers: { 'Content-Type': 'application/json' },\n                    timeout: this.config.timeoutDelay\n                }\n            );\n            \n            const result = response.data;\n            const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;\n            \n            if (!audioData) {\n                throw new Error('Dados de √°udio n√£o encontrados na resposta');\n            }\n            \n            return audioData;\n            \n        }, { priority: options.priority || 0 });\n    }\n}\n\nmodule.exports = RateLimiter;