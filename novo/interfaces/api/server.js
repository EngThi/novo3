/**\n * Unified API Server - Enterprise Express Server\n * Consolidates: monetization-server.js + other API endpoints\n * \n * Features:\n * - Express middleware pipeline with optimized routing\n * - Rate limiting per IP/API key with Redis fallback\n * - OpenAPI documentation with Swagger UI\n * - Health checks and monitoring endpoints\n * - Error handling middleware with structured logging\n * - CORS, compression, and security headers\n * - API versioning and backward compatibility\n */\n\nconst express = require('express');\nconst cors = require('cors');\nconst compression = require('compression');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst { v4: uuidv4 } = require('uuid');\n\nclass APIServer {\n    constructor(dependencies = {}) {\n        this.app = express();\n        this.server = null;\n        \n        this.pipelineCore = dependencies.pipelineCore;\n        this.ttsService = dependencies.ttsService;\n        this.imageService = dependencies.imageService;\n        this.videoService = dependencies.videoService;\n        this.cacheService = dependencies.cacheService;\n        this.jobQueue = dependencies.jobQueue;\n        this.logger = dependencies.logger || console;\n        \n        this.config = {\n            port: dependencies.config?.api?.port || 3000,\n            host: dependencies.config?.api?.host || '0.0.0.0',\n            apiVersion: 'v1',\n            enableDocs: dependencies.config?.api?.enableDocs !== false,\n            enableMetrics: dependencies.config?.api?.enableMetrics !== false,\n            rateLimitWindow: 15 * 60 * 1000, // 15 minutes\n            rateLimitMax: 100, // requests per window\n            ...dependencies.config?.api || {}\n        };\n        \n        this.metrics = {\n            requests: 0,\n            errors: 0,\n            responseTime: 0\n        };\n        \n        this.setupMiddleware();\n        this.setupRoutes();\n        this.setupErrorHandling();\n    }\n    \n    setupMiddleware() {\n        // Security\n        this.app.use(helmet());\n        this.app.use(cors());\n        \n        // Performance\n        this.app.use(compression());\n        this.app.use(express.json({ limit: '10mb' }));\n        this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));\n        \n        // Request ID tracking\n        this.app.use((req, res, next) => {\n            req.id = uuidv4();\n            res.setHeader('X-Request-ID', req.id);\n            next();\n        });\n        \n        // Rate limiting\n        const limiter = rateLimit({\n            windowMs: this.config.rateLimitWindow,\n            max: this.config.rateLimitMax,\n            standardHeaders: true,\n            legacyHeaders: false\n        });\n        this.app.use(limiter);\n        \n        // Request logging\n        this.app.use((req, res, next) => {\n            const start = Date.now();\n            res.on('finish', () => {\n                const duration = Date.now() - start;\n                this.logger.info(`${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`);\n                this.updateMetrics(duration);\n            });\n            next();\n        });\n    }\n    \n    setupRoutes() {\n        const router = express.Router();\n        \n        // Health check\n        router.get('/health', this.healthCheck.bind(this));\n        \n        // Pipeline endpoints\n        router.post('/generate', this.generateContent.bind(this));\n        router.post('/generate/batch', this.generateBatch.bind(this));\n        \n        // TTS endpoints\n        router.post('/tts/generate', this.generateTTS.bind(this));\n        \n        // Image endpoints\n        router.post('/images/generate', this.generateImage.bind(this));\n        router.post('/images/batch', this.generateImageBatch.bind(this));\n        \n        // Video endpoints\n        router.post('/videos/assemble', this.assembleVideo.bind(this));\n        \n        // Job management\n        router.get('/jobs/:id', this.getJob.bind(this));\n        router.post('/jobs/:id/cancel', this.cancelJob.bind(this));\n        router.post('/jobs/:id/retry', this.retryJob.bind(this));\n        \n        // Metrics\n        if (this.config.enableMetrics) {\n            router.get('/metrics', this.getMetrics.bind(this));\n        }\n        \n        this.app.use(`/api/${this.config.apiVersion}`, router);\n        \n        // Documentation\n        if (this.config.enableDocs) {\n            this.setupDocumentation();\n        }\n    }\n    \n    async generateContent(req, res) {\n        try {\n            const { prompt, options = {} } = req.body;\n            \n            if (!prompt) {\n                return res.status(400).json({ error: 'Prompt is required' });\n            }\n            \n            const result = await this.pipelineCore.execute({ prompt, ...options });\n            \n            res.json({\n                success: true,\n                data: result,\n                requestId: req.id\n            });\n            \n        } catch (error) {\n            this.handleError(res, error, req.id);\n        }\n    }\n    \n    async generateTTS(req, res) {\n        try {\n            const { text, options = {} } = req.body;\n            \n            if (!text) {\n                return res.status(400).json({ error: 'Text is required' });\n            }\n            \n            const result = await this.ttsService.generateAudio(text, options);\n            \n            res.json({\n                success: true,\n                data: {\n                    audioFile: result.file,\n                    duration: result.duration,\n                    provider: result.provider\n                },\n                requestId: req.id\n            });\n            \n        } catch (error) {\n            this.handleError(res, error, req.id);\n        }\n    }\n    \n    async generateImage(req, res) {\n        try {\n            const { prompt, options = {} } = req.body;\n            \n            if (!prompt) {\n                return res.status(400).json({ error: 'Prompt is required' });\n            }\n            \n            const result = await this.imageService.generateImage(prompt, options);\n            \n            res.json({\n                success: true,\n                data: {\n                    imageUrl: result.url,\n                    metadata: result.metadata\n                },\n                requestId: req.id\n            });\n            \n        } catch (error) {\n            this.handleError(res, error, req.id);\n        }\n    }\n    \n    async assembleVideo(req, res) {\n        try {\n            const { components, options = {} } = req.body;\n            \n            if (!components) {\n                return res.status(400).json({ error: 'Components are required' });\n            }\n            \n            const result = await this.videoService.assembleVideo(components, options);\n            \n            res.json({\n                success: true,\n                data: {\n                    videoFile: result.path,\n                    metadata: result.metadata\n                },\n                requestId: req.id\n            });\n            \n        } catch (error) {\n            this.handleError(res, error, req.id);\n        }\n    }\n    \n    async healthCheck(req, res) {\n        try {\n            const health = {\n                status: 'healthy',\n                timestamp: new Date().toISOString(),\n                uptime: process.uptime(),\n                version: this.config.apiVersion,\n                services: {}\n            };\n            \n            // Check service health\n            if (this.ttsService?.healthCheck) {\n                health.services.tts = await this.ttsService.healthCheck();\n            }\n            \n            if (this.imageService?.getStats) {\n                health.services.image = { status: 'healthy', stats: this.imageService.getStats() };\n            }\n            \n            if (this.videoService?.getStats) {\n                health.services.video = { status: 'healthy', stats: this.videoService.getStats() };\n            }\n            \n            res.json(health);\n            \n        } catch (error) {\n            res.status(500).json({\n                status: 'unhealthy',\n                error: error.message,\n                timestamp: new Date().toISOString()\n            });\n        }\n    }\n    \n    async getJob(req, res) {\n        try {\n            const job = await this.jobQueue.getJob(req.params.id);\n            \n            if (!job) {\n                return res.status(404).json({ error: 'Job not found' });\n            }\n            \n            res.json({\n                success: true,\n                data: job,\n                requestId: req.id\n            });\n            \n        } catch (error) {\n            this.handleError(res, error, req.id);\n        }\n    }\n    \n    async getMetrics(req, res) {\n        try {\n            const metrics = {\n                api: this.metrics,\n                pipeline: this.pipelineCore?.getStats(),\n                tts: this.ttsService?.getStats(),\n                image: this.imageService?.getStats(),\n                video: this.videoService?.getStats(),\n                cache: this.cacheService?.getStats(),\n                queue: this.jobQueue?.getQueueStats()\n            };\n            \n            res.json({\n                success: true,\n                data: metrics,\n                timestamp: new Date().toISOString()\n            });\n            \n        } catch (error) {\n            this.handleError(res, error, req.id);\n        }\n    }\n    \n    setupErrorHandling() {\n        this.app.use((err, req, res, next) => {\n            this.logger.error(`Unhandled error in request ${req.id}:`, err);\n            \n            this.metrics.errors++;\n            \n            res.status(500).json({\n                success: false,\n                error: 'Internal server error',\n                requestId: req.id\n            });\n        });\n    }\n    \n    handleError(res, error, requestId) {\n        this.logger.error(`Request ${requestId} failed:`, error);\n        this.metrics.errors++;\n        \n        res.status(500).json({\n            success: false,\n            error: error.message,\n            requestId\n        });\n    }\n    \n    updateMetrics(duration) {\n        this.metrics.requests++;\n        this.metrics.responseTime = \n            (this.metrics.responseTime * (this.metrics.requests - 1) + duration) / this.metrics.requests;\n    }\n    \n    async start() {\n        return new Promise((resolve) => {\n            this.server = this.app.listen(this.config.port, this.config.host, () => {\n                this.logger.info(`API Server running on http://${this.config.host}:${this.config.port}`);\n                resolve();\n            });\n        });\n    }\n    \n    async stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n}\n\nmodule.exports = APIServer;"